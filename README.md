# Javascript设计模式
## 1. **单例模式**  
### 核心概念：  
确保只有一个实例，并提供全局访问。比如全局缓存、浏览器中window对象等。  
### 模型：  
```
var obj;
if ( !obj ){
  obj = xxx;
}
return obj;
```
### 高度抽象的单例模式代码，惰性单例的精髓：
```
var getSingle = function (fn) {
  var result;
  return function () {
    return result || ( result = fn.apply(this, arguments) );
  }
};
```
## 2. **策略模式**  
### 核心概念：
定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。  
### 模型：  
```
var strategies = {
  A: fnA,
  b: fnB,
  ...
}
var calc = function(strategy, params) {
  return strategies[strategy](params);
}
```
### 优点：
* 策略模式利用组合、委托和多态等技术和思想，可以有效地避免多重条件选择语句。
* 策略模式提供了对开放-封闭原则的完美支持，将算法封装在独立的strategy中，使得它
们易于切换，易于理解，易于扩展。
* 策略模式中的算法也可以复用在系统的其他地方，从而避免许多重复的复制粘贴工作。
* 在策略模式中利用组合和委托来让 Context拥有执行算法的能力，这也是继承的一种更轻
便的替代方案。
### 缺点：
* 增加了许多策略类或者策略对象。
* 要使用策略模式，必须了解所有的strategy，违反了最少知识原则。
## 3. **代理模式**  
### 意义：
单一职责，代理做的代理的事情，本体只做本体的事情。代理和本体接口要一致，哪天不需要代理了，可以直接调用本体的接口，用户是无感的。
### 虚拟代理：
虚拟代理把一些开销很大的对象，延迟到真正需要它的时候才去创建。
### 缓存代理：
缓存代理可以为一些开销大的运算结果提供暂时的存储，在下次运算时，如果传递进来的参数跟之前一致，则可以直接返回前面存储的运算结果。
## 3. **观察者模式**
### 核心概念：
目标和观察者是基类，目标提供维护观察者的一系列方法，观察者提供更新接口。具体观察者和具体目标继承各自的基类，然后具体观察者把自己注册到具体目标里，在具体目标发生变化时候，调度观察者的更新方法。  
比如有个“天气中心”的具体目标A，专门监听天气变化，而有个显示天气的界面的观察者B，B就把自己注册到A里，当A触发天气变化，就调度B的更新方法，并带上自己的上下文。  
![观察者模式](http://images2015.cnblogs.com/blog/555379/201603/555379-20160313183429007-1351424959.png "观察者模式")
## 3. **发布/订阅模式**
### 核心概念：
订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。  
比如有个界面是实时显示天气，它就订阅天气事件（注册到调度中心，包括处理程序），当天气变化时（定时获取数据），就作为发布者发布天气信息到调度中心，调度中心就调度订阅者的天气处理程序。
![发布/订阅模式](http://images2015.cnblogs.com/blog/555379/201603/555379-20160313183439366-1623019133.png "发布/订阅模式")